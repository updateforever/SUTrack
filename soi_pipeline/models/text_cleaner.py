# pytracking/soi_pipeline/models/text_cleaner.py
import json
from typing import Dict, Optional
from openai import OpenAI


class TextCleaner:
    """文本清理器 - 负责Step 4的文本后处理"""
    
    def __init__(self, api_key: str, model: str = "qwen-plus", temperature: float = 0.3):
        self.client = OpenAI(

            api_key="sk-",  # 使用您的 Dashscope API 密钥
            base_url="https://dashscope.aliyuncs.com/compatible-mode/v1",

                             )
        self.model = model
        self.temperature = temperature
    
    def build_cleaning_prompt(self, raw_text: str) -> str:
        """构建清理提示词"""
        return f"""
You are given a four-level structured object description (level1 to level4) generated by a vision-language model. This description is intended to guide a multimodal model in accurately identifying the target object in a single object tracking (SOT) task.

Background:
In this task, the current frame contains multiple distractors that share similar visual appearance with the tracking target. The model must rely on both the textual description and visual inputs to determine **which object is the true target**. Specifically:
- Levels 1 to 3 describe the target's stable attributes (appearance, position, dynamic state, etc.);
- Level 4 should describe the most likely distractors directly, using a consistent structure.

Level 4 Cleaning Rule:
- Only retain distractor descriptions that are explicitly mentioned in the original text.
- Follow this structure strictly: relative position to the target (e.g., 'to the left of the target'), visual attributes of the distractor, and any described actions.
- Do NOT include phrases such as "may cause confusion", "could be mistaken", or any speculative or evaluative language.
- If a part is missing (e.g., no action), simply skip that part without making anything up.

Formatting Instructions:
- The four levels should naturally combine into one or two readable sentences.
- Level1 and level2 can end with commas to form a flowing phrase.
- Level3 should end with a period.
- Level4 may start a new sentence and also end with a period.
- Do not rewrite the original descriptions unless necessary. Preserve original wording and phrasing as much as possible.

Expected format:
```json
{{
  "level1": "...",
  "level2": "...",
  "level3": "...",
  "level4": "..."
}}
```

Example:
Original:
```json
{{
  "level1": "At the center of the underwater scene,",
  "level2": "a dark grey shark with a streamlined body and prominent dorsal fin,",
  "level3": "is gracefully swimming through the water.",
  "level4": "To the target’s left and right, there are numerous smaller silvery fish swimming in schools, which may distract due to their similar movement patterns and reflective scales."
}}
```
Cleaned:
```json
{{
  "level1": "At the center of the underwater scene,",
  "level2": "a dark grey shark with a streamlined body and prominent dorsal fin,",
  "level3": "is gracefully swimming through the water.",
  "level4": "To the target’s left and right, numerous smaller silvery fish are swimming in schools."
}}
```

Original model output:
{raw_text}
"""
    
    def extract_json_from_text(self, text: str) -> Optional[Dict]:
        """从文本中提取JSON"""
        try:
            # 查找JSON代码块
            if "```json" in text:
                text = text.split("```json")[-1].split("```")[0]
            elif "```" in text:
                # 尝试提取第一个代码块
                parts = text.split("```")
                if len(parts) >= 3:
                    text = parts[1]
            
            # 尝试解析JSON
            return json.loads(text.strip())
        
        except json.JSONDecodeError:
            # 如果解析失败，尝试查找花括号内容
            try:
                start_idx = text.find('{')
                end_idx = text.rfind('}')
                if start_idx != -1 and end_idx != -1 and end_idx > start_idx:
                    json_text = text[start_idx:end_idx+1]
                    return json.loads(json_text)
            except:
                pass
            
            print(f"Warning: Failed to parse JSON from text: {text[:100]}...")
            return None
    
    def clean_text(self, raw_text: str) -> Optional[Dict]:
        """清理VLM输出文本"""
        if not raw_text.strip():
            return None
        
        try:
            prompt = self.build_cleaning_prompt(raw_text)
            
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are a professional text processing assistant."},
                    {"role": "user", "content": prompt}
                ],
                temperature=self.temperature
            )
            
            result_text = response.choices[0].message.content
            return self.extract_json_from_text(result_text)
        
        except Exception as e:
            print(f"Warning: Text cleaning failed: {e}")
            return None